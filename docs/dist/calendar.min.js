(function () {
'use strict';

var hash = string => {
  let hash = 5381;
  let i = string.length;
  while (i) {
    hash = (hash * 33) ^ string.charCodeAt(--i);
  }
  return `_${hash >>> 0}`;
};

class StyleSheet {
  constructor() {
    const tag = document.createElement("style");
    tag.type = "text/css";
    tag.appendChild(document.createTextNode(""));
    this.tag = tag;
  }

  inject() {
    document.querySelector("head").appendChild(this.tag);
  }

  insert(selector, rule) {
    if (![].some.call(this.tag.childNodes, el => el.nodeValue === rule)) {
      this.tag.appendChild(document.createTextNode(rule));
    }
  }
}

const sheet = new StyleSheet();

const css = (...template) => {
  let cssText = "";
  const strings = template[0];
  for (var i = 1; i < template.length; i++) {
    cssText += strings[i - 1] + template[i];
  }
  cssText += strings.slice(i - 1);
  cssText = cssText.replace(/\s{2}/g, "");
  const className = hash(cssText);
  sheet.insert(`.${className}`, `.${className}{${cssText}}`);
  return className;
};

var connect = (container, component) => props =>
  container(Object.assign({}, props, { render: component }));

const sanitize = event => {
  // TODO: VALIDATE EVENT FORMAT

  event.uuid = hash(JSON.stringify(event));
  return event;
};

const byLength = (a, b) => (a.length >= b.length ? -1 : 1);

const byTime = (a, b) =>
  a.start > b.start || (a.start === b.start && a.end > b.end) ? 1 : -1;

const doOverlap = (eventA, eventB) =>
  eventB.start < eventA.end && eventB.end > eventA.start;

const flatten = array => array.reduce((acc, cur) => acc.concat(cur), []);

const uniques = array =>
  array.reduce(
    (uniques, event) => {
      if (!uniques[event.uuid]) {
        uniques[event.uuid] = true;
        uniques._results.push(event);
      }
      return uniques;
    },
    { _results: [] }
  )._results;

const getRow = (events, at) => {
  const intersection = {
    start: events[at].start,
    end: events[at].end,
    events: [events[at]]
  };
  const row = events.reduce((row, event, index) => {
    if (at !== index && doOverlap(event, row)) {
      row.start = event.start;
      if (event.end < row.end) {
        row.end = event.end;
      }
      row.events.push(event);
    }
    return row;
  }, intersection);

  return row.events;
};

const getRowHeads = events => {
  console.log(events);
  const row = {
    start: events[0].start,
    end: events[0].end
  };
  return events.reduce(
    (heads, event, index) => {
      if (doOverlap(event, row)) {
        row.start = event.start;
        if (event.end < row.end) {
          row.end = event.end;
        }
      } else {
        heads.push(index);
      }
      return heads;
    },
    [0]
  );
};

function getRows(events) {
  return getRowHeads(events).map(head => getRow(events, head));
}

const eventsContainerWidth = 620;
const eventsContainerHeight = 720;
const eventsLRPadding = 10;
const timeLineWidth = 60;
const timeLineSlotHeightInHours = 1;
const startTime = 9.0;
const endTime = 21.0;

var config = {
  eventData: [],
  timeLineProps: {
    timeLineSlotHeightInHours,
    startTime,
    endTime
  },
  eventsProps: {
    eventsLRPadding,
    eventsContainerHeight,
    eventsContainerWidth
  },
  calendarProps: {
    eventsContainerWidth,
    timeLineWidth
  }
};

function addWidths(rows) {
  return rows.sort(byLength).map(row => {
    let width = (eventsContainerWidth - eventsLRPadding * 2) / row.length;
    row.some(event => {
      if (event.width) {
        width = event.width;
        return true;
      }
    });
    return row.map(event => {
      event.width = width;
      return event;
    });
  });
}

function addOffsets(rows) {
  return rows.map(row =>
    row.map((event, index, row) => {
      if (event.offset === undefined) {
        event.offset = index;
      } else if (event.offset !== index) {
        const temp = row[event.offset];
        temp.offset = index;
        row[event.offset] = event;
        event = temp;
      }
      return event;
    })
  );
}

function layOutEvents(events) {
  const sanitizedEvents = events.map(sanitize).sort(byTime);  
  const rows = getRows(sanitizedEvents);
  const rowsWithWidths = addWidths(rows);
  const rowsWithOffsetsAndWidth = addOffsets(rowsWithWidths);
  return uniques(flatten(rowsWithOffsetsAndWidth));
}

const eventsContainer = ({eventsProps, eventData, mountedComponents, render}) => {
  
  const layOutDay = eventData => {    
    return render({ eventsProps, eventData: layOutEvents(eventData),  mountedComponents});
  };
  window.layOutDay = window.layOutDay || layOutDay;

  if (!eventData.length) {
    return render({eventsProps, eventData: [], mountedComponents});
  }
  return render({ eventsProps, eventData: layOutEvents(eventData),  mountedComponents });
};

const events = ({ eventData, eventsProps, mountedComponents }) => {
  const {eventsContainerWidth, eventsContainerHeight, eventsLRPadding} = eventsProps;
  const eventsNode = document.createElement("section");  
  
  eventsNode.className = css`
    position: relative;
    min-width: ${eventsContainerWidth}px;
    height: ${eventsContainerHeight}px;
    background-color: rgba(0, 0, 0, 0.1);
    background-image: linear-gradient(#ccc 1px, transparent 1px);
    background-size: 100% 30px;
  `;

  if (eventData.length) {
    eventData.forEach(event => {
      const eventNode = document.createElement("article");

      eventNode.className = css`
        position: absolute;
        border-left: 8px solid #3b5998;
        background-color: rgba(0,0,0,.1);
        top: ${event.start}px;
        left: ${event.width * event.offset + eventsLRPadding}px;
        height: ${event.end - event.start}px;
        width: ${event.width}px; 
      `;

      eventsNode.appendChild(eventNode);
    });
  }

  if (mountedComponents.calendar && mountedComponents.events) {
    mountedComponents.calendar.replaceChild(eventsNode, mountedComponents.events);
  }
  return mountedComponents.events = eventsNode;
};

var events$1 = connect(eventsContainer, events);

const time = ({ timeLineSlotHeightInHours, text }) => {
  const timeNode = document.createElement("p");

  timeNode.className = css`
    margin: 0;
    height: ${timeLineSlotHeightInHours * 60}px;
  `;

  timeNode.textContent = text;
  return timeNode;
};

const timeLine = ({ timeLineSlotHeightInHours, startTime, endTime }) => {
  const timelineNode = document.createElement("section");
  const slots = endTime - startTime / timeLineSlotHeightInHours;

  for (let i = 0; i < slots; i++) {
    const text =
      i + startTime <= 12 ? `${i + startTime} am` : `${i + startTime - 12} pm`;
    timelineNode.appendChild(time({ timeLineSlotHeightInHours, text }));
  }
  return timelineNode;
};

const calendar = ({ calendarProps, mountedComponents}) => {
  const {timeLineWidth, eventsContainerWidth} = calendarProps;
  const calendarNode = document.createElement("article");
  calendarNode.className = css`
    width: ${timeLineWidth + eventsContainerWidth}px;
    display: flex;
  `;

  return mountedComponents.calendar = calendarNode;
};

const app = {
  render({eventData, calendarProps, timeLineProps, eventsProps}, root) {
    const mountedComponents = {};

    // Instantiate an unmounted fragment for the application
    const appFragment = document.createDocumentFragment();

    // instantiate calendar component
    const calendarComponent = calendar({calendarProps, mountedComponents});

    // instantiate timeline component
    const timeLineComponent = timeLine(timeLineProps);
    // add the timeline to the calendar
    calendarComponent.appendChild(timeLineComponent);

    // instantiate event component
    const eventsComponent = events$1({eventsProps, eventData, mountedComponents});
    // add events to the calendar
    calendarComponent.appendChild(eventsComponent);

    // Mount the complete calendar application in the fragment
    appFragment.appendChild(calendarComponent);

    // If the application is not yet on the DOM, render it
    if (!root.hasChildNodes()) {
      sheet.inject();
      root.appendChild(appFragment);
    }
    return mountedComponents.calendarComponent;
  }
};

app.render(
  Object.assign({}, config, { eventData: [] }),
  document.getElementById("cal")
);

}());
